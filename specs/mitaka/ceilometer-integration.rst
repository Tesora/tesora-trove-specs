..
    This work is licensed under a Creative Commons Attribution 3.0 Unported
    License.

    http://creativecommons.org/licenses/by/3.0/legalcode

    Sections of this template were taken directly from the Nova spec
    template at:
    https://github.com/openstack/nova-specs/blob/master/specs/template.rst

======================
Ceilometer Integration
======================

The current implementation of trove supports 4 different operation
notifications to Ceilometer: trove.instance.create,
trove.instance.delete, trove.instance.modify_volume, and
trove.instance.modify_flavor.  An additional notification,
trove.instance.exists is generated periodically to provide status of
active instances.

This spec outlines how Trove can be extended to bring its notification
support to be more in line with the rest of Openstack by generating
start|end|fail notifications for all operation which result in a
change of state of the system.

Launchpad Blueprint:
https://blueprints.launchpad.net/trove/+spec/ceilometer-integration

.. sectnum::

.. contents::


Problem Description
===================

Trove does not support sufficient notifications for billing or error
monitoring.


Proposed Change
===============

Each Trove API call which results in a change of state will be
enhanced to generate notifications in line with other Openstack
projects.  Taskmanager tasks and asynchronous guest agent calls will
be supplemented with additional parameters to support the generation
of appropriate notifications.  A new RPC method will be added to the
Conductor to allow the guest to forward the results of asynchronous
calls as the guest agent may not have access to the control plane
where the Ceilometer collectors operate.

Each API event handler will generate appropriate start, end, and (if
necessary) error notifications.  For asynchronous calls to the
taskmanager or guest agent, the event handler will emit the start
notification and pass along sufficient information in the Trove
Context to allow subsequent components to generate the end and error
notifications.  Notification events generated by the Trove guest will
be forwarded to the Conductor to be placed on the Trove control plane
RabbitMQ broker.

Trove Status Notifications
--------------------------

These notifications have an event type of "trove.<action>".  They are
the notifications currently emitted by trove, enhanced to include the
cluster_id where appropriate.

All Trove status notifications will have the following information:

:Message:

|    event_type: trove.*
|      traits: &trove_base_traits
|        instance_type:
|          fields: payload.instance_type
|        user_id:
|          fields: payload.user_id
|        resource_id:
|          fields: payload.instance_id
|        instance_type_id:
|          fields: payload.instance_type_id
|        launched_at:
|          type: datetime
|          fields: payload.launched_at
|        instance_name:
|          fields: payload.instance_name
|        state:
|          fields: payload.state
|        state_description:
|          fields: payload.state_description
|        nova_instance_id:
|          fields: payload.nova_instance_id
|        service_id:
|          fields: payload.service_id
|        created_at:
|          type: datetime
|          fields: payload.created_at
|        region:
|          fields: payload.region

:instance_type: name of the flavor of the instance
:user_id: the id of the Openstack user who invoked the action
:resource_id: trove instance_id of the instance
:instance_type_id: flavor id of the flavor of the instance
:launched_at: same as created_at
:instance_name: name of the trove instance
:state: current state of the instance
:state_description: description of the current state of the instance
:nova_instance_id: id of the underlying nova instance
:service_id: notification service id for datastore
:created_at: creation time of the instance
:region: Openstack region

Trove status notifications for trove.create, trove.delete,
trove.modify_volume and trove.modify_flavor will have the following
additional information:

:Message:

|    event_type: ['trove.instance.create', 'trove.instance.modify_volume',
|                 'trove.instance.modify_flavor', 'trove.instance.delete']
|      traits: &trove_common_traits
|        name:
|          fields: payload.name
|        availability_zone:
|          fields: payload.availability_zone
|        instance_size:
|          type: int
|          fields: payload.instance_size
|        volume_size:
|          type: int
|          fields: payload.volume_size
|        nova_volume_id:
|          fields: payload.nova_volume_id
|        cluster_id:
|          fields: payload.cluster_id

:name: name of the Trove instance
:availability_zone: Openstack availability zone
:instance_size: ram allocated to instance
:volume_size: size of volume (if volume support enabled)
:nova_volume_id: nove volume id (if volume support enabled)
:cluster_id: id of cluster (if instance in cluster)


trove.instance.create
/////////////////////

:Message:

|    event_type: trove.instance.create
|      traits:
|        <<: [\*trove_base_traits, \*trove_common_traits]

trove.instance.delete
/////////////////////

:Message:

|    event_type: trove.instance.delete
|      traits:
|        <<: [\*trove_base_traits, \*trove_common_traits]
|        deleted_at:
|          type: datetime
|          fields: payload.deleted_at

:deleted_at: time at which instance deletion is complete

trove.instance.modify_volume
////////////////////////////

:Message:

|    event_type: trove.instance.modify_volume
|      traits:
|        <<: [\*trove_base_traits, \*trove_common_traits]
|        old_volume_size:
|          type: int
|          fields: payload.old_volume_size
|        modify_at:
|          type: datetime
|          fields: payload.modify_at

:old_volume_size: volume size prior to resize
:modify_at: time at which volume resize completed


trove.instance.modify_flavor
////////////////////////////

:Message:

|    event_type: trove.instance.modify_flavor
|      traits:
|        <<: [\*trove_base_traits, \*trove_common_traits]
|        old_instance_size:
|          type: int
|          fields: payload.old_instance_size
|        modify_at:
|          type: datetime
|          fields: payload.modify_at

:old_instance_size: memory of instance prior to resize
:modify_at: time at which resize completed

trove.instance.exists
/////////////////////

A periodic event to update statistics about each Trove instance.  This
notification is emitted only if configured via the
exists_notification_transformer config value.

:Message:

|    event_type: trove.instance.exists
|      traits:
|        <<: \*trove_base_traits
|        display_name:
|          fields: payload.display_name
|        audit_period_beginning:
|          type: datetime
|          fields: payload.audit_period_beginning
|        audit_period_ending:
|          type: datetime
|          fields: payload.audit_period_ending

:display_name: name of the instance
:audit_period_beginning: audit period start time
:audit_period_ending: audit period end time


dbaas.quotas
////////////

The dbaas.quotas notification will be periodically emitted to reflect
the current state of utilization of the Trove quotas.  The frequency
of notification events will be defined by the
quota_notification_interval configuration value, but at each interval
multiple events may be emitted for each resource due to Taskmanager
deployment configuration - each Taskmanager will emit a notification
for each resource.

:Message:

|    event_type: trove.quota
|      traits:
|        resource:
|          fields: payload.resource
|        in_use:
|          type: int
|          fields: payload.in_use
|        reserved:
|          type: int
|          fields: payload.reserved
|        limit:
|          type: int
|          fields: payload.limit
|        updated:
|          type: datetime
|          fields: payload.updated

:resource: name of resource (currently "instances", "volumes", or "backups")
:in_use: the number of resource instances currently in use
:reserved: the number of resource instances currently reserved
:limit: the maximum allocation of resource
:updated: the time of last resource allocation event


Trove API Notifications
-----------------------

See the Appendix at the end of this document for the individual API
notifications.


Configuration
-------------

A new configuration value will be added to support implementation of
periodic notifcations for quotas.

:quota_notification_interval:

    Seconds between periodic quota notifications (<0 to disable) [1]_.

Database
--------

No changes will be made to the Trove database.


Public API
----------

No changes will be made to the Trove REST API.

Public API Security
-------------------

n/a

Python API
----------

No changes will be made to the Trove Python API.

CLI (python-troveclient)
------------------------

No changes will be made to the Trove CLI.
n/a

Internal API
------------

Notification object instances representing the REST API calls that are
responsible for generating API Notification events will be created in
the Trove API process.  These notification objects will be created for
each REST API call which expects to change the state of the Trove
system, or one of the guest agents.  At the time the notification
object is created, the appropriate ".start" event will be generated
and published to the notification.info queue.

For operations which are processed completely within the trove-api
process, the appropriate ".end" or ".error" event will be published
upon completion of the operation.

For operations which require support from the Taskmanager or a guest
agent, the notification object will be attached to the TroveContext
instance for the operation.  The trove-taskmanager or trove-guestagent
will be able to retrieve the notification instance from the
TroveContext instance and use it to generate the appropriate
notification events.  The trove-taskmanager will place the
notification events directly on the RabbitMQ notification.info queue,
whereas the guest agent will forward the notification object to the
trove-conductor to be placed on the queue.

A new method will be added to the API for the Conductor.  The
following RPC method instructs the trove-conductor to send an end or
error notification with the appropriate values::

    def notify_exc_info(self, etype, value, trace):

:etype, value, trace: results from the sys.exc_info exception call.


Guest Agent
-----------

There will be no changes to the synchronous guest-agent RPC methods.

Asynchronous guest-agent methods will be modified to send ".end"
or".error" notifications to the trove-conductor to reflect the
completion status of each asynchronous RPC method.

It is expected that the current upgrade procedure where the guests are
upgraded before the trove controller components will be followed.  In
this scenario, no notifications will be added to the TroveContext, so
the guest agent will not send any notifications to the (yet to be
upgraded) trove-conductor.


Alternatives
------------

An alternative implementation would be to have the guest agent place
notifications directly on the notifications queue, but this would
require the guest agent to have access to the same RabbitMQ broker as
the trove-api and trove-taskmanager.  The proposed design is a step in
the direction of allowing the guest to operate in an isolated
environment.


Implementation
==============

Assignee(s)
-----------

Primary assignee:
  6-morgan


Milestones
----------

Target Milestone for completion:
  eg. Mitaka

Work Items
----------

* Develop framework for new notifications
* Re-implement existing notifications in new framework (for consistency)
* Implement new notification messages
* Implement TroveContext changes
* Integrate messages with synchronous API calls in trove-api
* Implement conductor RPC methods
* Integrate notifications with async Taskmanager RPC methods
* Integrate notifications with asynch guest agent RPC methods
* Update ceilometer message definitions for new notifications
* Unit tests for new code
* Modify existing tests to verify notifications
* Provide documentation for new notifications


Upgrade Implications
====================

* tenant-id will be added to ceilometer definition for existing Trove
  notifications
* new notifications will be added for all state changing REST APIs


Dependencies
============

n/a


Testing
=======

Existing unit tests will test changes to trove.* notifications.

New unit tests will be developed to test the new notifications.

The notification mechanism, when propely configured, adds
notifications to queues to be consumed by other Openstack, or
non-Openstack, components.  As these consumers are outside the scope
of Trove, integration tests do not test notifications.


Documentation Impact
====================

Documentation will be generated for the new notifications.


References
==========

.. [1] http://docs.openstack.org/developer/oslo-incubator/api/openstack.common.periodic_task.html


Appendix
========

Dbaas API Notification Definitions
----------------------------------

These are new notifications emitted by trove to reflect in invocation
of the various Trove APIs.

All DBAAS notifications will have an event type of
"dbaas.<action>.(start|end|error)" and include the following
information:

:Message:

| event_type: dbaas.\*
|  traits: &dbaas_base_traits
|    tenant_id:
|      fields: payload.tenant_id
|    client_ip:
|      fields: payload.client_ip
|    server_ip:
|      fields: payload.server_ip
|    server_type:
|      fields: payload.server_type
|    request_id:
|      fields: payload.request_id

:tenant_id: id of the configured tenant
:client_ip: ip:port of trove client which generated API invocation
:server_ip: ip:port of trove service which generated notification
:server_type: service which generated notification (api|task|conductor)
:request_id: Identifier used to correlate start|end|error


dbaas.instance_create.start
---------------------------

:Python API: instances.create(name, flavor_id, volume=None,
               databases=None, users=None,
               restorePoint=None, availability_zone=None, datastore=None,
               datastore_version=None, nics=None, configuration=None,
               replica_of=None, slave_of=None, replica_count=None)
:REST API: POST v1/{tenant_id}/instances/create
:Event Type: dbaas.instance_create.start
:Queue: notification.info
:Message:

|     event_type: dbaas.instance_create.start
|      traits:
|        <<: \*dbaas_base_traits
|        name:
|          fields: payload.name
|        flavor:
|          fields: payload.flavor
|        datastore:
|          fields: payload.datastore
|        databases:
|          fields: payload.databases
|        users:
|          fields: payload.users
|        volume_size:
|          type: int
|          fields: payload.volume_size
|        restore_point:
|          fields: payload.restore_point
|        availability_zone:
|          fields: payload.availability_zone
|        replica_of:
|          fields: payload.replica_of
|        replica_count:
|          fields: payload.replica_count

:name: Name of new instance
:flavor: Flavor id of instance
:datastore: Datastore of instance
:datastore_version: Datastore_version of instance
:databases: Comma separated list of databases to create (if specified)
:users: Comma separated list of users to create (if specified)
:volume_size: Size of volume to create (if specified)
:restore_point: Reference to backup to use to initialize instance (if
		specified)
:availability_zone: AZ of instance (if specified)
:replica_of: Master instance from which to create replica (if specified)
:replica_count: Number of replicas to create (if specified)

dbaas.instance_create.end
-------------------------

:Python API: instances.create(name, flavor_id, volume=None,
               databases=None, users=None,
               restorePoint=None, availability_zone=None, datastore=None,
               datastore_version=None, nics=None, configuration=None,
               replica_of=None, slave_of=None, replica_count=None)
:REST API: POST v1/{tenant_id}/instances/create
:Event Type: dbaas.instance_create.end
:Queue: notification.info
:Message:

|     event_type: dbaas.instance_create.end
|      traits:
|        <<: \*dbaas_base_traits
|        instance_id:
|          fields: payload.instance_id

:instance_id: id of created instance

dbaas.instance_create.error
---------------------------

:Python API: instances.create(name, flavor_id, volume=None,
               databases=None, users=None,
               restorePoint=None, availability_zone=None, datastore=None,
               datastore_version=None, nics=None, configuration=None,
               replica_of=None, slave_of=None, replica_count=None)
:REST API: POST v1/{tenant_id}/instances/create
:Event Type: dbaas.instance_create.error
:Queue: notification.error
:Message:

|     event_type: dbaas.instance_create.error
|      traits:
|        <<: \*dbaas_base_traits
|        instance_id:
|          fields: payload.instance_id
|        message:
|          fields: payload.message
|        exception:
|          fields: payload.exception


:instance_id: id of instance
:message: message of exception (duplicated from stack trace)
:exception: stack trace of exception


dbaas.instance_restart.start
----------------------------

:Python API: instances.restart(instance)
:REST API: POST v1/{tenant_id}/instances/{id}/action
:Event Type: dbaas.instance_restart.start
:Queue: notification.info
:Message:

|     event_type: dbaas.instance_restart.start
|      traits:
|        <<: \*dbaas_base_traits
|        instance_id:
|          fields: payload.instance_id

:instance_id: id of instance to restart


dbaas.instance_restart.end
--------------------------

:Python API: instances.restart(instance)
:REST API: POST v1/{tenant_id}/instances/{id}/action
:Event Type: dbaas.instance_restart.end
:Queue: notification.info
:Message:

|     event_type: dbaas.instance_restart.end
|      traits:
|        <<: \*dbaas_base_traits


dbaas.instance_restart.error
----------------------------

:Python API: instances.restart(instance)
:REST API: POST v1/{tenant_id}/instances/{id}/action
:Event Type: dbaas.instance_restart.error
:Queue: notification.error
:Message:

|     event_type: dbaas.instance_restart.error
|      traits:
|        <<: \*dbaas_base_traits
|        message:
|          fields: payload.message
|        exception:
|          fields: payload.exception

:message: message of exception (duplicated from stack trace)
:exception: stack trace of exception


dbaas.instance_resize_volume.start
----------------------------------

:Python API: instances.resize_volume(instance, volume_size)
:REST API: POST v1/{tenant_id}/instances/{id}/action
:Event Type: dbaas.instance_resize_volume.start
:Queue: notification.info
:Message:

|     event_type: dbaas.instance_resize_volume.start
|      traits:
|        <<: \*dbaas_base_traits
|        instance_id:
|          fields: payload.instance_id
|        new_size:
|          type: int
|          fields: payload.new_size

:instance_id: id of instance to resize_volume
:new_size: size to which volume will be resized

dbaas.instance_resize_volume.end
--------------------------------

:Python API: instances.resize_volume(instance, volume_size)
:REST API: POST v1/{tenant_id}/instances/{id}/action
:Event Type: dbaas.instance_resize_volume.end
:Queue: notification.info
:Message:

|     event_type: dbaas.instance_resize_volume.end
|      traits:
|        <<: \*dbaas_base_traits


dbaas.instance_resize_volume.error
----------------------------------

:Python API: instances.resize_volume(instance, volume_size)
:REST API: POST v1/{tenant_id}/instances/{id}/action
:Event Type: dbaas.instance_resize_volume.error
:Queue: notification.error
:Message:

|     event_type: dbaas.instance_resize_volume.error
|      traits:
|        <<: \*dbaas_base_traits
|        message:
|          fields: payload.message
|        exception:
|          fields: payload.exception

:message: message of exception (duplicated from stack trace)
:exception: stack trace of exception


dbaas.instance_resize_instance.start
------------------------------------

:Python API: instances.resize_instance(instance, flavor_id)
:REST API: POST v1/{tenant_id}/instances/{id}/action
:Event Type: dbaas.instance_resize_instance.start
:Queue: notification.info
:Message:

|     event_type: dbaas.instance_resize_instance.start
|      traits:
|        <<: \*dbaas_base_traits
|        instance_id:
|          fields: payload.instance_id
|        new_flavor_id:
|          fields: payload.new_flavor_id

:instance_id: id of instance to resize_instance
:new_flavor_id: id of flavor to which instance will be resized

dbaas.instance_resize_instance.end
----------------------------------

:Python API: instances.resize_instance(instance, flavor_id)
:REST API: POST v1/{tenant_id}/instances/{id}/action
:Event Type: dbaas.instance_resize_instance.end
:Queue: notification.info
:Message:

|     event_type: dbaas.instance_resize_instance.end
|      traits:
|        <<: \*dbaas_base_traits


dbaas.instance_resize_instance.error
------------------------------------

:Python API: instances.resize_instance(instance, flavor_id)
:REST API: POST v1/{tenant_id}/instances/{id}/action
:Event Type: dbaas.instance_resize_instance.error
:Queue: notification.error
:Message:

|     event_type: dbaas.instance_resize_instance.error
|      traits:
|        <<: \*dbaas_base_traits
|        message:
|          fields: payload.message
|        exception:
|          fields: payload.exception

:message: message of exception (duplicated from stack trace)
:exception: stack trace of exception


dbaas.instance_promote.start
----------------------------

:Python API: instances.promote_to_replica_source(instance)
:REST API: POST v1/{tenant_id}/instances/{id}/action
:Event Type: dbaas.instance_promote.start
:Queue: notification.info
:Message:

|     event_type: dbaas.instance_promote.start
|      traits:
|        <<: \*dbaas_base_traits
|        instance_id:
|          fields: payload.instance_id

:instance_id: id of instance to promote

dbaas.instance_promote.end
--------------------------

:Python API: instances.promote_to_replica_source(instance)
:REST API: POST v1/{tenant_id}/instances/{id}/action
:Event Type: dbaas.instance_promote.end
:Queue: notification.info
:Message:

|     event_type: dbaas.instance_promote.end
|      traits:
|        <<: \*dbaas_base_traits


dbaas.instance_promote.error
----------------------------

:Python API: instances.promote_to_replica_source(instance)
:REST API: POST v1/{tenant_id}/instances/{id}/action
:Event Type: dbaas.instance_promote.error
:Queue: notification.error
:Message:

|     event_type: dbaas.instance_promote.error
|      traits:
|        <<: \*dbaas_base_traits
|        message:
|          fields: payload.message
|        exception:
|          fields: payload.exception

:message: message of exception (duplicated from stack trace)
:exception: stack trace of exception


dbaas.instance_eject.start
--------------------------

:Python API: instances.eject_replica_source(instance)
:REST API: POST v1/{tenant_id}/instances/{id}/action
:Event Type: dbaas.instance_eject.start
:Queue: notification.info
:Message:

|     event_type: dbaas.instance_eject.start
|      traits:
|        <<: \*dbaas_base_traits
|        instance_id:
|          fields: payload.instance_id

:instance_id: id of instance to eject

dbaas.instance_eject.end
------------------------

:Python API: instances.eject_replica_source(instance)
:REST API: POST v1/{tenant_id}/instances/{id}/action
:Event Type: dbaas.instance_eject.end
:Queue: notification.info
:Message:

|     event_type: dbaas.instance_eject.end
|      traits:
|        <<: \*dbaas_base_traits


dbaas.instance_eject.error
--------------------------

:Python API: instances.eject_replica_source(instance)
:REST API: POST v1/{tenant_id}/instances/{id}/action
:Event Type: dbaas.instance_eject.error
:Queue: notification.error
:Message:

|     event_type: dbaas.instance_eject.error
|      traits:
|        <<: \*dbaas_base_traits
|        message:
|          fields: payload.message
|        exception:
|          fields: payload.exception

:message: message of exception (duplicated from stack trace)
:exception: stack trace of exception


dbaas.instance_delete.start
---------------------------

:Python API: instances.delete(instance)
:REST API: DELETE v1/{tenant_id}/instances/{id}
:Event Type: dbaas.instance_delete.start
:Queue: notification.info
:Message:

|     event_type: dbaas.instance_delete.start
|      traits:
|        <<: \*dbaas_base_traits
|        instance_id:
|          fields: payload.instance_id

:instance_id: id of instance to delete

dbaas.instance_delete.end
-------------------------

:Python API: instances.delete(instance)
:REST API: DELETE v1/{tenant_id}/instances/{id}
:Event Type: dbaas.instance_delete.end
:Queue: notification.info
:Message:

|     event_type: dbaas.instance_delete.end
|      traits:
|        <<: \*dbaas_base_traits


dbaas.instance_delete.error
---------------------------

:Python API: instances.delete(instance)
:REST API: DELETE v1/{tenant_id}/instances/{id}
:Event Type: dbaas.instance_delete.error
:Queue: notification.error
:Message:

|     event_type: dbaas.instance_delete.error
|      traits:
|        <<: \*dbaas_base_traits
|        message:
|          fields: payload.message
|        exception:
|          fields: payload.exception

:message: message of exception (duplicated from stack trace)
:exception: stack trace of exception


dbaas.instance_detach.start
---------------------------

:Python API: instances.edit(detach_replica_source=True)
:REST API: PATCH v1/{tenant_id}/instances/{id}
:Event Type: dbaas.instance_detach.start
:Queue: notification.info
:Message:

|     event_type: dbaas.instance_detach.start
|      traits:
|        <<: \*dbaas_base_traits
|        instance_id:
|          fields: payload.instance_id

:instance_id: id of instance to detach

dbaas.instance_detach.end
-------------------------

:Python API: instances.edit(detach_replica_source=True)
:REST API: PATCH v1/{tenant_id}/instances/{id}
:Event Type: dbaas.instance_detach.end
:Queue: notification.info
:Message:

|     event_type: dbaas.instance_detach.end
|      traits:
|        <<: \*dbaas_base_traits


dbaas.instance_detach.error
---------------------------

:Python API: instances.edit(detach_replica_source=True)
:REST API: PATCH v1/{tenant_id}/instances/{id}
:Event Type: dbaas.instance_detach.error
:Queue: notification.error
:Message:

|     event_type: dbaas.instance_detach.error
|      traits:
|        <<: \*dbaas_base_traits
|        message:
|          fields: payload.message
|        exception:
|          fields: payload.exception

:message: message of exception (duplicated from stack trace)
:exception: stack trace of exception


dbaas.instance_attach_configuration.start
-----------------------------------------

:Python API: instances.modify(instance, configuration)
:REST API: PATCH v1/{tenant_id}/instances/{id}
:Event Type: dbaas.instance_attach_configuration.start
:Queue: notification.info
:Message:

|     event_type: dbaas.instance_attach_configuration.start
|      traits:
|        <<: \*dbaas_base_traits
|        instance_id:
|          fields: payload.instance_id
|        configuration_id:
|          fields: payload.configuration_id

:instance_id: id of instance to attach_configuration
:configuration_id:  id of configuration to attach

dbaas.instance_attach_configuration.end
---------------------------------------

:Python API: instances.modify(instance, configuration)
:REST API: PATCH v1/{tenant_id}/instances/{id}
:Event Type: dbaas.instance_attach_configuration.end
:Queue: notification.info
:Message:

|     event_type: dbaas.instance_attach_configuration.end
|      traits:
|        <<: \*dbaas_base_traits


dbaas.instance_attach_configuration.error
-----------------------------------------

:Python API: instances.modify(instance, configuration)
:REST API: PATCH v1/{tenant_id}/instances/{id}
:Event Type: dbaas.instance_attach_configuration.error
:Queue: notification.error
:Message:

|     event_type: dbaas.instance_attach_configuration.error
|      traits:
|        <<: \*dbaas_base_traits
|        message:
|          fields: payload.message
|        exception:
|          fields: payload.exception

:message: message of exception (duplicated from stack trace)
:exception: stack trace of exception


dbaas.instance_detach_configuration.start
-----------------------------------------

:Python API: instances.edit(instance, configuration, remove_configuration=True)
:REST API: PATCH v1/{tenant_id}/instances/{id}
:Event Type: dbaas.instance_detach_configuration.start
:Queue: notification.info
:Message:

|     event_type: dbaas.instance_detach_configuration.start
|      traits:
|        <<: \*dbaas_base_traits
|        instance_id:
|          fields: payload.instance_id

:instance_id: id of instance to detach_configuration

dbaas.instance_detach_configuration.end
---------------------------------------

:Python API: instances.edit(instance, configuration, remove_configuration=True)
:REST API: PATCH v1/{tenant_id}/instances/{id}
:Event Type: dbaas.instance_detach_configuration.end
:Queue: notification.info
:Message:

|     event_type: dbaas.instance_detach_configuration.end
|      traits:
|        <<: \*dbaas_base_traits


dbaas.instance_detach_configuration.error
-----------------------------------------

:Python API: instances.edit(instance, configuration, remove_configuration=True)
:REST API: PATCH v1/{tenant_id}/instances/{id}
:Event Type: dbaas.instance_detach_configuration.error
:Queue: notification.error
:Message:

|     event_type: dbaas.instance_detach_configuration.error
|      traits:
|        <<: \*dbaas_base_traits
|        message:
|          fields: payload.message
|        exception:
|          fields: payload.exception

:message: message of exception (duplicated from stack trace)
:exception: stack trace of exception


dbaas.cluster_create.start
--------------------------

:Python API: clusters.create(name, datastore, datastore_version,
	     instances=None)
:REST API: POST v1/{tenant_id}/clusters
:Event Type: dbaas.cluster_create.start
:Queue: notification.info
:Message:

|     event_type: dbaas.cluster_create.start
|      traits:
|        <<: \*dbaas_base_traits
|        name:
|          fields: payload.name
|        datastore:
|          fields: payload.datastore
|        datastore_version:
|          fields: payload.datastore_version

:name: name of cluster
:datastore: datastore of cluster
:datastore_version: datastore_version of cluster

dbaas.cluster_create.end
------------------------

:Python API: clusters.create(name, datastore, datastore_version,
	     instances=None)
:REST API: POST v1/{tenant_id}/clusters
:Event Type: dbaas.cluster_create.end
:Queue: notification.info
:Message:

|     event_type: dbaas.cluster_create.end
|      traits:
|        <<: \*dbaas_base_traits
|        cluster_id:
|          fields: payload.cluster_id

:cluster_id: id of newly created cluster

dbaas.cluster_create.error
--------------------------

:Python API: clusters.create(name, datastore, datastore_version,
	     instances=None)
:REST API: POST v1/{tenant_id}/clusters
:Event Type: dbaas.cluster_create.error
:Queue: notification.error
:Message:

|     event_type: dbaas.cluster_create.error
|      traits:
|        <<: \*dbaas_base_traits
|        message:
|          fields: payload.message
|        exception:
|          fields: payload.exception

:message: message of exception (duplicated from stack trace)
:exception: stack trace of exception


dbaas.cluster_delete.start
--------------------------

:Python API: clusters.delete(cluster)
:REST API: DELETE v1/{tenant_id}/clusters/{id}
:Event Type: dbaas.cluster_delete.start
:Queue: notification.info
:Message:

|     event_type: dbaas.cluster_delete.start
|      traits:
|        <<: \*dbaas_base_traits
|        cluster_id:
|          fields: payload.cluster_id

:cluster_id: id of cluster to delete

dbaas.cluster_delete.end
------------------------

:Python API: clusters.delete(cluster)
:REST API: DELETE v1/{tenant_id}/clusters/{id}
:Event Type: dbaas.cluster_delete.end
:Queue: notification.info
:Message:

|     event_type: dbaas.cluster_delete.end
|      traits:
|        <<: \*dbaas_base_traits


dbaas.cluster_delete.error
--------------------------

:Python API: clusters.delete(cluster)
:REST API: DELETE v1/{tenant_id}/clusters/{id}
:Event Type: dbaas.cluster_delete.error
:Queue: notification.error
:Message:

|     event_type: dbaas.cluster_delete.error
|      traits:
|        <<: \*dbaas_base_traits
|        message:
|          fields: payload.message
|        exception:
|          fields: payload.exception

:message: message of exception (duplicated from stack trace)
:exception: stack trace of exception


dbaas.cluster_add_shard.start
-----------------------------

:Python API: clusters.add_shard(cluster)
:REST API: POST v1/{tenant_id}/clusters/{id}
:Event Type: dbaas.cluster_add_shard.start
:Queue: notification.info
:Message:

|     event_type: dbaas.cluster_add_shard.start
|      traits:
|        <<: \*dbaas_base_traits
|        cluster_id:
|          fields: payload.cluster_id

:cluster_id: id of cluster to which to add a shard

dbaas.cluster_add_shard.end
---------------------------

:Python API: clusters.add_shard(cluster)
:REST API: POST v1/{tenant_id}/clusters/{id}
:Event Type: dbaas.cluster_add_shard.end
:Queue: notification.info
:Message:

|     event_type: dbaas.cluster_add_shard.end
|      traits:
|        <<: \*dbaas_base_traits


dbaas.cluster_add_shard.error
-----------------------------

:Python API: clusters.add_shard(cluster)
:REST API: POST v1/{tenant_id}/clusters/{id}
:Event Type: dbaas.cluster_add_shard.error
:Queue: notification.error
:Message:

|     event_type: dbaas.cluster_add_shard.error
|      traits:
|        <<: \*dbaas_base_traits
|        message:
|          fields: payload.message
|        exception:
|          fields: payload.exception

:message: message of exception (duplicated from stack trace)
:exception: stack trace of exception


dbaas.cluster_grow.start
------------------------

:Python API: clusters.grow(cluster, instances)
:REST API: POST v1/{tenant_id}/clusters/{id}
:Event Type: dbaas.cluster_grow.start
:Queue: notification.info
:Message:

|     event_type: dbaas.cluster_grow.start
|      traits:
|        <<: \*dbaas_base_traits
|        cluster_id:
|          fields: payload.cluster_id

:cluster_id: id of cluster to which to add a shard

dbaas.cluster_grow.end
----------------------

:Python API: clusters.grow(cluster, instances)
:REST API: POST v1/{tenant_id}/clusters/{id}
:Event Type: dbaas.cluster_grow.end
:Queue: notification.info
:Message:

|     event_type: dbaas.cluster_grow.end
|      traits:
|        <<: \*dbaas_base_traits


dbaas.cluster_grow.error
------------------------

:Python API: clusters.grow(cluster, instances)
:REST API: POST v1/{tenant_id}/clusters/{id}
:Event Type: dbaas.cluster_grow.error
:Queue: notification.error
:Message:

|     event_type: dbaas.cluster_grow.error
|      traits:
|        <<: \*dbaas_base_traits
|        message:
|          fields: payload.message
|        exception:
|          fields: payload.exception

:message: message of exception (duplicated from stack trace)
:exception: stack trace of exception


dbaas.cluster_shrink.start
--------------------------

:Python API: clusters.shrink(cluster, instances)
:REST API: POST v1/{tenant_id}/clusters/{id}
:Event Type: dbaas.cluster_shrink.start
:Queue: notification.info
:Message:

|     event_type: dbaas.cluster_shrink.start
|      traits:
|        <<: \*dbaas_base_traits
|        cluster_id:
|          fields: payload.cluster_id

:cluster_id: id of cluster to which to add a shard

dbaas.cluster_shrink.end
------------------------

:Python API: clusters.shrink(cluster, instances)
:REST API: POST v1/{tenant_id}/clusters/{id}
:Event Type: dbaas.cluster_shrink.end
:Queue: notification.info
:Message:

|     event_type: dbaas.cluster_shrink.end
|      traits:
|        <<: \*dbaas_base_traits


dbaas.cluster_shrink.error
--------------------------

:Python API: clusters.shrink(cluster, instances)
:REST API: POST v1/{tenant_id}/clusters/{id}
:Event Type: dbaas.cluster_shrink.error
:Queue: notification.error
:Message:

|     event_type: dbaas.cluster_shrink.error
|      traits:
|        <<: \*dbaas_base_traits
|        message:
|          fields: payload.message
|        exception:
|          fields: payload.exception

:message: message of exception (duplicated from stack trace)
:exception: stack trace of exception


dbaas.backup_create.start
-------------------------

:Python API: backups.create(name, instance=None, description=None,
	     parent_id=None, backup=None)
:REST API: POST v1/{tenant_id}/backups
:Event Type: dbaas.backup_create.start
:Queue: notification.info
:Message:

|     event_type: dbaas.backup_create.start
|      traits:
|        <<: \*dbaas_base_traits
|        name:
|          fields: payload.name
|        instance_id:
|          fields: payload.instance_id
|        description:
|          fields: payload.description
|        parent_id:
|          fields: payload.parent_id

:name: name of backup
:instance_id: id of instance of which to create backup
:description: description of backup
:parent_id: id of backup of which to take incremental backup

dbaas.backup_create.end
-----------------------

:Python API: backups.create(name, instance=None, description=None,
	     parent_id=None, backup=None)
:REST API: POST v1/{tenant_id}/backups
:Event Type: dbaas.backup_create.end
:Queue: notification.info
:Message:

|     event_type: dbaas.backup_create.end
|      traits:
|        <<: \*dbaas_base_traits
|        backup_id:
|          fields: payload.backup_id

:backup_id: id of newly created backup

dbaas.backup_create.error
-------------------------

:Python API: backups.create(name, instance=None, description=None,
	     parent_id=None, backup=None)
:REST API: POST v1/{tenant_id}/backups
:Event Type: dbaas.backup_create.error
:Queue: notification.error
:Message:

|     event_type: dbaas.backup_create.error
|      traits:
|        <<: \*dbaas_base_traits
|        message:
|          fields: payload.message
|        exception:
|          fields: payload.exception

:message: message of exception (duplicated from stack trace)
:exception: stack trace of exception


dbaas.backup_delete.start
-------------------------

:Python API: backups.delete(backup_id)
:REST API: DELETE v1/{tenant_id}/backups/{id}
:Event Type: dbaas.backup_delete.start
:Queue: notification.info
:Message:

|     event_type: dbaas.backup_delete.start
|      traits:
|        <<: \*dbaas_base_traits
|        backup_id:
|          fields: payload.backup_id

:backup_id: id of backup to delete

dbaas.backup_delete.end
-----------------------

:Python API: backups.delete(backup_id)
:REST API: DELETE v1/{tenant_id}/backups/{id}
:Event Type: dbaas.backup_delete.end
:Queue: notification.info
:Message:

|     event_type: dbaas.backup_delete.end
|      traits:
|        <<: \*dbaas_base_traits


dbaas.backup_delete.error
-------------------------

:Python API: backups.delete(backup_id)
:REST API: DELETE v1/{tenant_id}/backups/{id}
:Event Type: dbaas.backup_delete.error
:Queue: notification.error
:Message:

|     event_type: dbaas.backup_delete.error
|      traits:
|        <<: \*dbaas_base_traits
|        message:
|          fields: payload.message
|        exception:
|          fields: payload.exception

:message: message of exception (duplicated from stack trace)
:exception: stack trace of exception


dbaas.database_create.start
---------------------------

Note that a single call to databases.create would generate a separate
notification for each database to be created.

:Python API: databases.create(instance, databases)
:REST API: POST v1/{tenant_id}/databases
:Event Type: dbaas.database_create.start
:Queue: notification.info
:Message:

|     event_type: dbaas.database_create.start
|      traits:
|        <<: \*dbaas_base_traits
|        instance_id:
|          fields: payload.instance_id
|        dbname:
|          fields: payload.dbname

:instance_id: id of instance of which to create database
:dbname: name of database to be created

dbaas.database_create.end
-------------------------

:Python API: databases.create(instance, databases)
:REST API: POST v1/{tenant_id}/databases
:Event Type: dbaas.database_create.end
:Queue: notification.info
:Message:

|     event_type: dbaas.database_create.end
|      traits:
|        <<: \*dbaas_base_traits


dbaas.database_create.error
---------------------------

:Python API: databases.create(instance, databases)
:REST API: POST v1/{tenant_id}/databases
:Event Type: dbaas.database_create.error
:Queue: notification.error
:Message:

|     event_type: dbaas.database_create.error
|      traits:
|        <<: \*dbaas_base_traits
|        message:
|          fields: payload.message
|        exception:
|          fields: payload.exception

:message: message of exception (duplicated from stack trace)
:exception: stack trace of exception


dbaas.database_delete.start
---------------------------

:Python API: databases.delete(database_id)
:REST API: DELETE v1/{tenant_id}/databases/{id}
:Event Type: dbaas.database_delete.start
:Queue: notification.info
:Message:

|     event_type: dbaas.database_delete.start
|      traits:
|        <<: \*dbaas_base_traits
|        instance_id:
|          fields: payload.instance_id
|        dbname:
|          fields: payload.dbname

:instance_id: id of instance from which to delete database
:dbname: name of database to delete

dbaas.database_delete.end
-------------------------

:Python API: databases.delete(database_id)
:REST API: DELETE v1/{tenant_id}/databases/{id}
:Event Type: dbaas.database_delete.end
:Queue: notification.info
:Message:

|     event_type: dbaas.database_delete.end
|      traits:
|        <<: \*dbaas_base_traits


dbaas.database_delete.error
---------------------------

:Python API: databases.delete(database_id)
:REST API: DELETE v1/{tenant_id}/databases/{id}
:Event Type: dbaas.database_delete.error
:Queue: notification.error
:Message:

|     event_type: dbaas.database_delete.error
|      traits:
|        <<: \*dbaas_base_traits
|        message:
|          fields: payload.message
|        exception:
|          fields: payload.exception

:message: message of exception (duplicated from stack trace)
:exception: stack trace of exception


dbaas.user_create.start
-----------------------

Note that a single call to users.create would generate a separate
notification for each user to be created.

:Python API: users.create(instance, users)
:REST API: POST v1/{tenant_id}/instances/{instance}/users
:Event Type: dbaas.user_create.start
:Queue: notification.info
:Message:

|     event_type: dbaas.user_create.start
|      traits:
|        <<: \*dbaas_base_traits
|        instance_id:
|          fields: payload.instance_id
|        username:
|          fields: payload.username

:instance_id: id of instance for which to create user
:username: name of user to be created


dbaas.user_create.end
---------------------

:Python API: users.create(instance, users)
:REST API: POST v1/{tenant_id}/instances/{instance}/users
:Event Type: dbaas.user_create.end
:Queue: notification.info
:Message:

|     event_type: dbaas.user_create.end
|      traits:
|        <<: \*dbaas_base_traits


dbaas.user_create.error
-----------------------

:Python API: users.create(instance, users)
:REST API: POST v1/{tenant_id}/instances/{instance}/users
:Event Type: dbaas.user_create.error
:Queue: notification.error
:Message:

|     event_type: dbaas.user_create.error
|      traits:
|        <<: \*dbaas_base_traits
|        message:
|          fields: payload.message
|        exception:
|          fields: payload.exception

:message: message of exception (duplicated from stack trace)
:exception: stack trace of exception


dbaas.user_delete.start
-----------------------

:Python API: users.delete(instance, username, hostname)
:REST API: DELETE v1/{tenant_id}/instances/{instance}/users/{id}
:Event Type: dbaas.user_delete.start
:Queue: notification.info
:Message:

|     event_type: dbaas.user_delete.start
|      traits:
|        <<: \*dbaas_base_traits
|        instance_id:
|          fields: payload.instance_id
|        username:
|          fields: payload.username

:instance_id: id of instance from which to delete user
:username: name of user to delete

dbaas.user_delete.end
---------------------

:Python API: users.delete(instance, username, hostname)
:REST API: DELETE v1/{tenant_id}/instances/{instance}/users/{id}
:Event Type: dbaas.user_delete.end
:Queue: notification.info
:Message:

|     event_type: dbaas.user_delete.end
|      traits:
|        <<: \*dbaas_base_traits


dbaas.user_delete.error
-----------------------

:Python API: users.delete(instance, username, hostname)
:REST API: DELETE v1/{tenant_id}/instances/{instance}/users/{id}
:Event Type: dbaas.user_delete.error
:Queue: notification.error
:Message:

|     event_type: dbaas.user_delete.error
|      traits:
|        <<: \*dbaas_base_traits
|        message:
|          fields: payload.message
|        exception:
|          fields: payload.exception

:message: message of exception (duplicated from stack trace)
:exception: stack trace of exception


dbaas.user_update_attributes.start
----------------------------------

:Python API: users.update_attributes(self, instance, username,
	     newuserattr=None, hostname=None)
:REST API: PUT v1/{tenant_id}/instances/{instance}/users/{id}
:Event Type: dbaas.user_update_attributes.start
:Queue: notification.info
:Message:

|     event_type: dbaas.user_update_attributes.start
|      traits:
|        <<: \*dbaas_base_traits
|        instance_id:
|          fields: payload.instance_id
|        username:
|          fields: payload.username

:instance_id: id of instance for which to update attributes
:username: name of user for whom to update attributes

dbaas.user_update_attributes.end
--------------------------------

:Python API: users.update_attributes(self, instance, username,
	     newuserattr=None, hostname=None)
:REST API: PUT v1/{tenant_id}/instances/{instance}/users/{id}
:Event Type: dbaas.user_update_attributes.end
:Queue: notification.info
:Message:

|     event_type: dbaas.user_update_attributes.end
|      traits:
|        <<: \*dbaas_base_traits


dbaas.user_update_attributes.error
----------------------------------

:Python API: users.update_attributes(self, instance, username,
	     newuserattr=None, hostname=None)
:REST API: PUT v1/{tenant_id}/instances/{instance}/users/{id}
:Event Type: dbaas.user_update_attributes.error
:Queue: notification.error
:Message:

|     event_type: dbaas.user_update_attributes.error
|      traits:
|        <<: \*dbaas_base_traits
|        message:
|          fields: payload.message
|        exception:
|          fields: payload.exception

:message: message of exception (duplicated from stack trace)
:exception: stack trace of exception


dbaas.user_grant.start
----------------------

Note  that a  single  call  to users.grant  would  generate  a set  of
notifications for each database to which the user is granted access.

:Python API: users.grant(instance, username, databases, hostname=None)
:REST API: PUT v1/{tenant_id}/instances/{instance}/users/{id}/databases
:Event Type: dbaas.user_grant.start
:Queue: notification.info
:Message:

|     event_type: dbaas.user_grant.start
|      traits:
|        <<: \*dbaas_base_traits
|        instance_id:
|          fields: payload.instance_id
|        username:
|          fields: payload.username
|        database:
|          fields: payload.database

:instance_id: id of instance from which to grant user
:username: name of user to grant access to database
:database: name of database to which access will be granted

dbaas.user_grant.end
--------------------

:Python API: users.grant(instance, username, databases, hostname=None)
:REST API: PUT v1/{tenant_id}/instances/{instance}/users/{id}/databases
:Event Type: dbaas.user_grant.end
:Queue: notification.info
:Message:

|     event_type: dbaas.user_grant.end
|      traits:
|        <<: \*dbaas_base_traits


dbaas.user_grant.error
----------------------

:Python API: users.grant(instance, username, databases, hostname=None)
:REST API: PUT v1/{tenant_id}/instances/{instance}/users/{id}/databases
:Event Type: dbaas.user_grant.error
:Queue: notification.error
:Message:

|     event_type: dbaas.user_grant.error
|      traits:
|        <<: \*dbaas_base_traits
|        message:
|          fields: payload.message
|        exception:
|          fields: payload.exception

:message: message of exception (duplicated from stack trace)
:exception: stack trace of exception


dbaas.user_revoke.start
-----------------------

:Python API: users.revoke(instance, username, database, hostname=None)
:REST API: PUT v1/{tenant_id}/instances/{instance}/users/{id}/databases/{database}
:Event Type: dbaas.user_revoke.start
:Queue: notification.info
:Message:

|     event_type: dbaas.user_revoke.start
|      traits:
|        <<: \*dbaas_base_traits
|        instance_id:
|          fields: payload.instance_id
|        username:
|          fields: payload.username
|        database:
|          fields: payload.database

:instance_id: id of instance from which to revoke user
:username: name of user to revoke access to database
:database: name of database to which access will be revoked

dbaas.user_revoke.end
---------------------

:Python API: users.revoke(instance, username, databases, hostname=None)
:REST API: PUT v1/{tenant_id}/instances/{instance}/users/{id}/databases/{database}
:Event Type: dbaas.user_revoke.end
:Queue: notification.info
:Message:

|     event_type: dbaas.user_revoke.end
|      traits:
|        <<: \*dbaas_base_traits


dbaas.user_revoke.error
-----------------------

:Python API: users.revoke(instance, username, databases, hostname=None)
:REST API: PUT v1/{tenant_id}/instances/{instance}/users/{id}/databases/{database}
:Event Type: dbaas.user_revoke.error
:Queue: notification.error
:Message:

|     event_type: dbaas.user_revoke.error
|      traits:
|        <<: \*dbaas_base_traits
|        message:
|          fields: payload.message
|        exception:
|          fields: payload.exception

:message: message of exception (duplicated from stack trace)
:exception: stack trace of exception


dbaas.user_change_password.start
--------------------------------

Note that a single call to users.change_password would result in a
separate notification event for each changed user.

:Python API: users.change_password(instance, users)
:REST API: PUT v1/{tenant_id}/instances/{instance}/users
:Event Type: dbaas.user_change_password.start
:Queue: notification.info
:Message:

|     event_type: dbaas.user_change_password.start
|      traits:
|        <<: \*dbaas_base_traits
|        instance_id:
|          fields: payload.instance_id
|        username:
|          fields: payload.username

:instance_id: id of instance from which to change_password user
:username: name of user for which password changed

dbaas.user_change_password.end
------------------------------

:Python API: users.change_password(instance, users)
:REST API: PUT v1/{tenant_id}/instances/{instance}/users
:Event Type: dbaas.user_change_password.end
:Queue: notification.info
:Message:

|     event_type: dbaas.user_change_password.end
|      traits:
|        <<: \*dbaas_base_traits


dbaas.user_change_password.error
--------------------------------

:Python API: users.change_password(instance, users)
:REST API: PUT v1/{tenant_id}/instances/{instance}/users
:Event Type: dbaas.user_change_password.error
:Queue: notification.error
:Message:

|     event_type: dbaas.user_change_password.error
|      traits:
|        <<: \*dbaas_base_traits
|        message:
|          fields: payload.message
|        exception:
|          fields: payload.exception

:message: message of exception (duplicated from stack trace)
:exception: stack trace of exception


dbaas.configuration_create.start
--------------------------------

:Python API: configurations.create(name, values, description=None,
	     datastore=None, datastore_version=None)
:REST API: POST v1/{tenant_id}/configurations
:Event Type: dbaas.configuration_create.start
:Queue: notification.info
:Message:

|     event_type: dbaas.configuration_create.start
|      traits:
|        <<: \*dbaas_base_traits
|        name:
|          fields: payload.name
|        datastore:
|          fields: payload.datastore
|        datastore_version:
|          fields: payload.datastore_version

:name: name of configuration to create
:datastore: datastore of configuration
:datastore_version: datastore_version of configuration

dbaas.configuration_create.end
------------------------------

:Python API: configurations.create(name, values, description=None,
	     datastore=None, datastore_version=None)
:REST API: POST v1/{tenant_id}/configurations
:Event Type: dbaas.configuration_create.end
:Queue: notification.info
:Message:

|     event_type: dbaas.configuration_create.end
|      traits:
|        <<: \*dbaas_base_traits
|        configuration_id:
|          fields: payload.configuration_id

:configuration_id: id of newly created configuration

dbaas.configuration_create.error
--------------------------------

:Python API: configurations.create(name, values, description=None,
	     datastore=None, datastore_version=None)
:REST API: POST v1/{tenant_id}/configurations
:Event Type: dbaas.configuration_create.error
:Queue: notification.error
:Message:

|     event_type: dbaas.configuration_create.error
|      traits:
|        <<: \*dbaas_base_traits
|        message:
|          fields: payload.message
|        exception:
|          fields: payload.exception

:message: message of exception (duplicated from stack trace)
:exception: stack trace of exception


dbaas.configuration_delete.start
--------------------------------

:Python API: configurations.delete(configuration_id)
:REST API: DELETE v1/{tenant_id}/configurations/{id}
:Event Type: dbaas.configuration_delete.start
:Queue: notification.info
:Message:

|     event_type: dbaas.configuration_delete.start
|      traits:
|        <<: \*dbaas_base_traits
|        configuration_id:
|          fields: payload.configuration_id

:configuration_id: id of configuration to delete

dbaas.configuration_delete.end
------------------------------

:Python API: configurations.delete(configuration_id)
:REST API: DELETE v1/{tenant_id}/configurations/{id}
:Event Type: dbaas.configuration_delete.end
:Queue: notification.info
:Message:

|     event_type: dbaas.configuration_delete.end
|      traits:
|        <<: \*dbaas_base_traits


dbaas.configuration_delete.error
--------------------------------

:Python API: configurations.delete(configuration_id)
:REST API: DELETE v1/{tenant_id}/configurations/{id}
:Event Type: dbaas.configuration_delete.error
:Queue: notification.error
:Message:

|     event_type: dbaas.configuration_delete.error
|      traits:
|        <<: \*dbaas_base_traits
|        message:
|          fields: payload.message
|        exception:
|          fields: payload.exception

:message: message of exception (duplicated from stack trace)
:exception: stack trace of exception


dbaas.configuration_update.start
--------------------------------

:Python API: configurations.update(configuration_id, values, name=None,
	     description=None)
:REST API: PUT v1/{tenant_id}/configurations/{id}
:Event Type: dbaas.configuration_update.start
:Queue: notification.info
:Message:

|     event_type: dbaas.configuration_update.start
|      traits:
|        <<: \*dbaas_base_traits
|        configuration_id:
|          fields: payload.configuration_id
|        name:
|          fields: payload.name
|        description:
|          fields: payload.description

:configuration_id: id of configuration to update
:name: new group name (if specified)
:description: new group description (if specified)

dbaas.configuration_update.end
------------------------------

:Python API: configurations.update(configuration_id, values, name=None,
	     description=None)
:REST API: PUT v1/{tenant_id}/configurations/{id}
:Event Type: dbaas.configuration_update.end
:Queue: notification.info
:Message:

|     event_type: dbaas.configuration_update.end
|      traits:
|        <<: \*dbaas_base_traits


dbaas.configuration_update.error
--------------------------------

:Python API: configurations.update(configuration_id, values, name=None,
	     description=None)
:REST API: PUT v1/{tenant_id}/configurations/{id}
:Event Type: dbaas.configuration_update.error
:Queue: notification.error
:Message:

|     event_type: dbaas.configuration_update.error
|      traits:
|        <<: \*dbaas_base_traits
|        message:
|          fields: payload.message
|        exception:
|          fields: payload.exception

:message: message of exception (duplicated from stack trace)
:exception: stack trace of exception


dbaas.configuration_edit.start
------------------------------

:Python API: configurations.edit(configuration_id, values)
:REST API: PATCH v1/{tenant_id}/configurations/{id}
:Event Type: dbaas.configuration_edit.start
:Queue: notification.info
:Message:

|     event_type: dbaas.configuration_edit.start
|      traits:
|        <<: \*dbaas_base_traits
|        configuration_id:
|          fields: payload.configuration_id

:configuration_id: id of configuration to edit

dbaas.configuration_edit.end
----------------------------

:Python API: configurations.edit(configuration_id, values)
:REST API: PATCH v1/{tenant_id}/configurations/{id}
:Event Type: dbaas.configuration_edit.end
:Queue: notification.info
:Message:

|     event_type: dbaas.configuration_edit.end
|      traits:
|        <<: \*dbaas_base_traits


dbaas.configuration_edit.error
------------------------------

:Python API: configurations.edit(configuration_id, values)
:REST API: PATCH v1/{tenant_id}/configurations/{id}
:Event Type: dbaas.configuration_edit.error
:Queue: notification.error
:Message:

|     event_type: dbaas.configuration_edit.error
|      traits:
|        <<: \*dbaas_base_traits
|        message:
|          fields: payload.message
|        exception:
|          fields: payload.exception

:message: message of exception (duplicated from stack trace)
:exception: stack trace of exception
